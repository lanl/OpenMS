#
# @ 2023. Triad National Security, LLC. All rights reserved.
#
# This program was produced under U.S. Government contract 89233218CNA000001
# for Los Alamos National Laboratory (LANL), which is operated by Triad
# National Security, LLC for the U.S. Department of Energy/National Nuclear
# Security Administration. All rights in the program are reserved by Triad
# National Security, LLC, and the U.S. Department of Energy/National Nuclear
# Security Administration. The Government is granted for itself and others acting
# on its behalf a nonexclusive, paid-up, irrevocable worldwide license in this
# material to reproduce, prepare derivative works, distribute copies to the
# public, perform publicly and display publicly, and to permit others to do so.
#
# Authors:   Yu Zhang    <zhy@lanl.gov>
#          Ilia Mazin <imazin@lanl.gov>
#

r"""
Theoretical background of QEDHF
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Within the Coherent State (CS) representation (for photonic DOF), the
QEDHF wavefunction ansatz is

.. math::

   \ket{\Psi} = &\sum_n c_n \prod_\alpha e^{z_\alpha b^\dagger_\alpha - z^*_\alpha b_\alpha } \ket{HF}\otimes{n_\alpha} \\
              = &\sum_n c_n U(\mathbf{z}) \ket{HF}\otimes{n_\alpha}.

where :math:`z_\alpha=-\frac{\lambda_\alpha\cdot\langle\boldsymbol{D}\rangle}{\sqrt{2\omega_\alpha}}` denotes
the photon displacement due to the coupling with electrons.

Consequently, we can use :math:`U(\mathbf{z})` to transform the original PF Hamiltonian
into CS representation

.. math::

    H_{CS} = & U^\dagger(\mathbf{z}) H U(\mathbf{z}) \\
           = & H_e+\sum_\alpha\Big\{\omega_\alpha b^\dagger_\alpha b_\alpha
               +\frac{1}{2}[\lambda_\alpha\cdot(\boldsymbol{D}-\langle\boldsymbol{D}\rangle)]^2  \\
             & -\sqrt{\frac{\omega_\alpha}{2}}[\lambda_\alpha\cdot(\boldsymbol{D} -
             \langle\boldsymbol{D}\rangle)](b^\dagger_\alpha+ b_\alpha)\Big\}.


With the ansatz, the QEDHF energy is

.. math::

  E_{QEDHF}= E_{HF} + \frac{1}{2}\langle \boldsymbol{\lambda}\cdot [\boldsymbol{D}-\langle \boldsymbol{D}\rangle)]^2\rangle,

"""

import numpy
import time

from pyscf.dft import rks
from pyscf import lib
from pyscf import scf
from pyscf.scf import hf
from pyscf.lib import logger

import openms
from openms.lib import boson
from openms import __config__
from openms.lib.logger import task_title

TIGHT_GRAD_CONV_TOL = getattr(__config__, "TIGHT_GRAD_CONV_TOL", True)


def kernel(
    mf, conv_tol=1e-10, conv_tol_grad=None,
    dump_chk=True, dm0=None, callback=None, conv_check=True, **kwargs):
    r"""
    SCF kernel: the main QED-HF driver.

    Modified version of :external:func:`hf.kernel <pyscf.scf.hf.kernel>`
    from PySCF. The main difference is:

    - updating one-electron integrals with :meth:`~RHF.get_hcore` within
      the SCF cycle, due to new DSE-mediated terms in the OEI which depend
      on the electronic density matrix, ``dm``.

    Parameters
    ----------
    mf : :class:`RHF <mqed.qedhf.RHF>`
        Instance of OpenMS mean-field class.

    Keyword Arguments
    -----------------
    conv_tol : float
        Energy convergence threshold.
        **Optional**, ``default = 1e-10``.
    conv_tol_grad : float
        Energy gradients convergence threshold.
        **Optional**, ``default = sqrt(conv_tol)``.
    dump_chk : bool
        Whether to save SCF intermediate results
        in the checkpoint file.
        **Optional**, ``default = True``.
    dm0 : :class:`~numpy.ndarray`
        Initial guess density matrix. If not given (the default),
        the kernel takes the density matrix generated by
        :external:meth:`~pyscf.scf.hf.SCF.get_init_guess`.
    callback : function(envs_dict) => None
        callback function takes one ``dict`` as the argument which
        is generated by built-in function :func:`locals`, so that
        the callback function can access all local variables in the
        current environment.
    conv_check : bool
        Whether to perform an additional SCF cycle after convergence
        criteria are met. **Optional**, ``default = True``.

    Return
    ------
    scf_conv : bool
        Whether SCF has converged.
    e_tot : float
        QED Hartree-Fock energy of last iteration.
    mo_energy : :class:`~numpy.ndarray`
        Orbital energies. Depending on the ``eig`` function provided by
        ``mf`` object, the orbital energies may **NOT** be sorted.
    mo_coeff : :class:`~numpy.ndarray`
        Orbital coefficients.
    mo_occ : :class:`~numpy.ndarray`
        Orbital occupancies. The occupancies may **NOT** be sorted from
        large to small.
    """

    if 'init_dm' in kwargs:
        err_msg = "You see this error message because of the API " + \
                  "updates in pyscf v0.11. Keyword argument 'init_dm' " + \
                  "is replaced by 'dm0'"
        raise RuntimeError(err_msg)

    cput0 = (logger.process_clock(), logger.perf_counter())

    if conv_tol_grad is None:
        conv_tol_grad = numpy.sqrt(conv_tol)
        log_msg = f"Set gradient convergence threshold to {conv_tol_grad}"
        logger.info(mf, log_msg)

    mol = mf.mol
    s1e = mf.get_ovlp(mol)

    if dm0 is None:
        dm = mf.get_init_guess(mol, mf.init_guess)
    else:
        dm = dm0

    # Initialize parameters (used in SC/VT-QEDHF)
    mf.init_var_params(dm)

    # construct h1e, gmat in DO representation (used in SC/VT-QEDHF)
    mf.get_h1e_DO(mol, dm=dm)

    # Coherent-state z_alpha values
    if mf.qed.use_cs:
        mf.qed.update_cs(dm)

    # Create initial photonic eigenvector guess(es)
    mf.qed.update_boson_coeff(dm)

    # Initial electronic energy
    h1e = mf.get_hcore(mol, dm)
    vhf = mf.get_veff(mol, dm)
    e_tot = mf.energy_tot(dm, h1e, vhf)
    logger.info(mf, 'init E= %.15g', e_tot)

    scf_conv = False
    mo_energy = mo_coeff = mo_occ = None

    # Skip SCF iterations. Compute only the total energy of the initial density
    if mf.max_cycle <= 0:
        fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf, no DIIS
        mo_energy, mo_coeff = mf.eig(fock, s1e)
        mo_occ = mf.get_occ(mo_energy, mo_coeff)
        return scf_conv, e_tot, mo_energy, mo_coeff, mo_occ

    # Setup DIIS parameters
    if isinstance(mf.diis, lib.diis.DIIS):
        mf_diis = mf.diis
    elif mf.diis:
        assert issubclass(mf.DIIS, lib.diis.DIIS)
        mf_diis = mf.DIIS(mf, mf.diis_file)
        mf_diis.space = mf.diis_space
        mf_diis.rollback = mf.diis_space_rollback

        fock = mf.get_fock(h1e, s1e, vhf, dm)
        _, mf_diis.Corth = mf.eig(fock, s1e)
    else:
        mf_diis = None

    if dump_chk and mf.chkfile:
        # Explicitly overwrite the mol object in chkfile
        # Note in pbc.scf, mf.mol == mf.cell, cell is saved under key "mol"
        scf.chkfile.save_mol(mol, mf.chkfile)

    # A preprocessing hook before the SCF iteration(s)
    mf.pre_kernel(locals())
    mf.check_sanity()

    mf.cycles = 0
    cput1 = logger.timer(mf, 'initialize scf', *cput0)
    for cycle in range(mf.max_cycle):
        dm_last = dm
        last_hf_e = e_tot

        # Update gradients of additional variational parameters
        # and 'h1e' in DO basis (used by SC-QED-HF/VT-QED-HF subclasses)
        mf.get_h1e_DO(mol, dm=dm)
        mf.grad_var_params(dm)

        h1e = mf.get_hcore(mol, dm)
        fock = mf.get_fock(h1e, s1e, vhf, dm, cycle, mf_diis)

        # Diagonalize Fock matrix and update density matrix
        mo_energy, mo_coeff = mf.eig(fock, s1e)
        mo_occ = mf.get_occ(mo_energy, mo_coeff)
        dm = mf.make_rdm1(mo_coeff, mo_occ)

        # Update photonic coefficients and compute photonic energy
        mf.qed.update_cs(dm) # Update coherent state values

        # Update h1e, vhf, and e_tot
        h1e = mf.get_hcore(mol, dm)
        vhf = mf.get_veff(mol, dm, dm_last, vhf)
        e_tot = mf.energy_tot(dm, h1e, vhf)

        # construct Hp matrix and diagonalize
        mf.qed.update_boson_coeff(dm)

        # Check SCF convergence
        fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf, no DIIS
        norm_eta = mf.norm_var_params()
        norm_gorb = numpy.linalg.norm(mf.get_grad(mo_coeff, mo_occ, fock))
        norm_gorb += norm_eta
        if not TIGHT_GRAD_CONV_TOL:
            norm_gorb = norm_gorb / numpy.sqrt(norm_gorb.size)
        norm_ddm = numpy.linalg.norm(dm-dm_last)
        logger.info(mf, 'cycle= %d E= %.15g  delta_E= %4.3g  |g|= %4.3g  |ddm|= %4.3g',
                    cycle+1, e_tot, e_tot-last_hf_e, norm_gorb, norm_ddm)

        if callable(mf.check_convergence):
            scf_conv = mf.check_convergence(locals())
        elif abs(e_tot-last_hf_e) < conv_tol and norm_gorb < conv_tol_grad:
            scf_conv = True

        if dump_chk:
            mf.dump_chk(locals())

        if callable(callback):
            callback(locals())

        cput1 = logger.timer(mf, 'cycle= %d'%(cycle+1), *cput1)

        if scf_conv:
            break

    mf.cycles = cycle + 1
    if scf_conv and conv_check:

        # An extra diagonalization, to remove level shift
        mo_energy, mo_coeff = mf.eig(fock, s1e)
        mo_occ = mf.get_occ(mo_energy, mo_coeff)
        dm, dm_last = mf.make_rdm1(mo_coeff, mo_occ), dm

        # Final update of photonic coefficients and energy
        mf.qed.update_cs(dm) # Update coherent state values
        mf.qed.update_boson_coeff(dm)

        # Final update of h1e, vhf, e_tot, fock
        h1e = mf.get_hcore(mol, dm)
        vhf = mf.get_veff(mol, dm, dm_last, vhf)

        e_tot, last_hf_e = mf.energy_tot(dm, h1e, vhf), e_tot
        fock = mf.get_fock(h1e, s1e, vhf, dm)

        # Verify SCF convergence
        norm_eta = mf.norm_var_params()
        norm_gorb = numpy.linalg.norm(mf.get_grad(mo_coeff, mo_occ, fock))
        norm_gorb = norm_gorb + norm_eta
        if not TIGHT_GRAD_CONV_TOL:
            norm_gorb = norm_gorb / numpy.sqrt(norm_gorb.size)
        norm_ddm = numpy.linalg.norm(dm-dm_last)

        conv_tol = conv_tol * 10
        conv_tol_grad = conv_tol_grad * 3
        if callable(mf.check_convergence):
            scf_conv = mf.check_convergence(locals())
        elif abs(e_tot-last_hf_e) < conv_tol or norm_gorb < conv_tol_grad:
            scf_conv = True
        logger.info(mf, 'Extra cycle  E= %.15g  delta_E= %4.3g  |g|= %4.3g  |ddm|= %4.3g',
                    e_tot, e_tot-last_hf_e, norm_gorb, norm_ddm)
        if dump_chk:
            mf.dump_chk(locals())

    logger.timer(mf, 'scf_cycle', *cput0)
    # A post-processing hook before return
    mf.post_kernel(locals())
    return scf_conv, e_tot, mo_energy, mo_coeff, mo_occ


def get_fock(
    mf,
    h1e=None,
    s1e=None,
    vhf=None,
    dm=None,
    cycle=-1,
    diis=None,
    diis_start_cycle=None,
    level_shift_factor=None,
    damp_factor=None,
):
    r"""
    Return Fock matrix in AO basis, :math:`F = h_{core} + V_{HF}`.

    Copy of :func:`hf.get_fock <pyscf.scf.hf.get_fock>`
    from PySCF with some differences:

        1. Generalize DIIS to include other variational parameters,
        2. Pre- and post-processing of variational parameters with
           :meth:`update_var_params` & :meth:`pre_update_var_params`,
        3. ``h1e`` depends on the density matrix.

    Parameters
    ----------
    mf : :class:`RHF <mqed.qedhf.RHF>`
        Instance of OpenMS mean-field class.

    Keyword Arguments
    -----------------
    h1e : :class:`~numpy.ndarray`
        Core QED-HF Hamiltonian. If ``None``,
        :meth:`~RHF.get_hcore` called.
    s1e : :class:`~numpy.ndarray`
        Overlap matrix, for DIIS. If ``None``,
        :external:func:`~pyscf.scf.hf.get_ovlp` called.
    vhf : :class:`~numpy.ndarray`
        QED-HF potential matrix. If ``None``,
        :meth:`~RHF.get_veff` called.
    dm : :class:`~numpy.ndarray`
        Density matrix. If ``None``,
        :external:func:`~pyscf.scf.hf.make_rdm1` called.
    cycle : int
        Present SCF iteration step, for DIIS,
        ``default = -1``.
    diis : :external:class:`~pyscf.lib.diis.DIIS`
        DIIS object to hold intermediate Fock and error
        vectors.
    diis_start_cycle : int
        The step to start DIIS, **optional**
        ``default = 0``.
    level_shift_factor : float
        Level shift (in AU) for virtual space, **optional**
        ``default = 0``.
    damp_factor : float
        Damping factor for Fock matrix, **optional**
        ``default = 0``.

    Return
    ------
    f : :class:`~numpy.ndarray`
        Fock matrix.
    """

    if cycle > -1:
        mf.update_var_params()

    h1e = mf.get_hcore(dm=dm)
    if vhf is None:
        vhf = mf.get_veff(mf.mol, dm)

    f = h1e + vhf

    if cycle < 0 and diis is None:  # Not inside the SCF iteration
        return f

    if diis_start_cycle is None:
        diis_start_cycle = mf.diis_start_cycle
    if level_shift_factor is None:
        level_shift_factor = mf.level_shift
    if damp_factor is None:
        damp_factor = mf.damp

    if dm is None: dm = mf.make_rdm1()
    if s1e is None: s1e = mf.get_ovlp()

    if 0 <= cycle < diis_start_cycle - 1 and abs(damp_factor) > 1e-4:
        f = damping(s1e, dm * 0.5, f, damp_factor) # TODO: will produce error if damping is used
    if diis is not None and cycle >= diis_start_cycle:
        variables, gradients = mf.pre_update_var_params()
        params = diis.update(s1e, dm, f, mf, h1e, vhf, var=variables, var_grad=gradients)
        f = mf.set_params(params, fock_shape=f.shape)
    if abs(level_shift_factor) > 1e-4:
        f = level_shift(s1e, dm * 0.5, f, level_shift_factor) # TODO: will produce error if level_shift is used
    return f


class RHF(hf.RHF):
    r"""Non-relativistic QED-RHF class."""
    def __init__(self, mol, **kwargs):

        # print headers
        logger.info(self, openms.__logo__)
        if "pccp2023" not in openms.runtime_refs:
            openms.runtime_refs.append("pccp2023")

        xc = kwargs.get("xc", None)
        if xc is not None:
            raise NotImplementedError("RKS object currently not supported.")
        else:
            super().__init__(mol)

        self.nao = mol.nao_nr()
        self.bare_h1e = None
        self.oei = None
        self.qed = None

        qed = kwargs.get("qed", None)
        cavity = kwargs.get("cavity", None)

        cavity_options = kwargs
        if qed is None:
            if "cavity_mode" in kwargs:
                cavity_options["vec"] = kwargs["cavity_mode"]
            elif not "vec" in kwargs:
                raise ValueError("The required keyword argument 'cavity_mode or vec' is missing")

            if "cavity_freq" in kwargs:
                cavity_options["omega"] = kwargs["cavity_freq"]
            elif not "omega" in kwargs:
                raise ValueError("The required keyword argument 'cavity_freq' is missing")

            qed = boson.Photon(mol, mf=self, **cavity_options)

        elif qed is not None and (not isinstance(qed, boson.Boson)):
            err_msg = f"The 'qed' parameter is not an " + \
                      f"instance of OpenMS Boson class."
            logger.error(self, err_msg)
            raise ValueError(err_msg)
        else:
            # update the mf attribute of qed
            qed._mf = self

        # Update QED object
        self.qed = qed
        # qed.update_mean_field(self, **kwargs) # TODO: Remove eventually

        # update the setting according to each specific MF
        # couplings_var should be zero in QEDHF
        qed.couplings_var = numpy.zeros(qed.nmodes)
        qed.update_couplings()

        # make dipole matrix in AO
        self.qed.get_gmatao()
        self.qed.get_q_dot_lambda()

        return


    def get_oei_AO(self):
        r"""return the effective oei in AO for usage in QMC
        """
        pass


    def get_eri_AO(sefl, Ltensor=True):
        r"""return the effective eri (or chols) in AO for usage in QMC
        """
        pass


    def get_hcore(self, mol=None, dm=None):
        r"""
        Return non-QED or DSE-mediated OEI in AO basis.

        DSE-mediated oei is

            h_{dse} = -<\lambda\cdot D> g^\alpha_{uv} - 0.5 q^\alpha_{uv}
                    = -Tr[\rho g^\alpha] g^\alpha_{uv} - 0.5 q^\alpha_{uv}

        If ``dm=None``, return non-QED OEI, stored in
        :attr:`bare_h1e`.

        Else, call :meth:`~lib.boson.Photon.get_dse_hcore`
        from :attr:`qed` object to return the DSE-mediated
        OEI contribution.

        Keyword Arguments
        -----------------
        mol : :class:`MoleBase <pyscf.gto.mole.MoleBase>`
            PySCF molecule object. If ``None``, copied from
            :attr:`mol` attribute.
        dm : :class:`~numpy.ndarray`
            Density matrix, **optional**.

        Returns
        -------
        :class:`~numpy.ndarray`
            non-QED OEI or DSE-mediated OEI.
        """

        if mol is None: mol = self.mol

        self.bare_h1e = self.get_bare_hcore(mol)

        if dm is None:
            return self.bare_h1e
        else:
            self.oei = self.qed.add_oei_ao(dm)
            return (self.bare_h1e + self.oei)


    def get_dse_jk(self, dm, residue=False, compute_grad=False):
        r"""DSE-mediated JK terms

        To be deprecated, use boson.get_dse_jk instead in the future

        Note: this term exists even if we don't use CS representation
        don't simply replace this term with z since z can be zero without CS.
        effective DSE-mediated eri is:

             I' = lib.einsum("Xpq, Xrs->pqrs", gmat, gmat)

        The residual DSE are

        .. math ::
             H_{DSE} &= \frac{(1-f)^2}{2}(\boldsymbol{\lambda}\cdot\boldsymbol{D})^2 \textit{(with bare DSE)} \\
                     &= \frac{f^2-2f}{2}(\boldsymbol{\lambda}\cdot\boldsymbol{D})^2  \textit{(without bare DSE)} \\

        """

        dm_shape = dm.shape
        dm = dm.reshape(-1, self.nao, self.nao)
        n_dm = dm.shape[0]
        logger.debug(self, "No. of dm is %d", n_dm)

        grad_vjk = numpy.zeros((n_dm, self.nao, self.nao))
        vj_dse = numpy.zeros((n_dm, self.nao, self.nao))
        vk_dse = numpy.zeros((n_dm, self.nao, self.nao))

        gtmp = self.qed.gmat
        gvar2 = numpy.ones(self.qed.nmodes)
        if residue:
            if self.qed.add_dse:
                gvar2 = self.qed.couplings_res**2 # element-wise
            else:
                gvar2 = self.qed.couplings_var * (self.qed.couplings_var - 2.0)
            dg = - 2.00 * self.qed.couplings_res # 2(f-1)

        for i in range(n_dm):
            # DSE-medaited J
            scaled_mu = lib.einsum("pq, Xpq ->X", dm[i], gtmp) # <\lambada * D>
            vj_dse[i] += lib.einsum("Xpq, X, X->pq", gtmp, scaled_mu, gvar2)
            if compute_grad:
                # FIXME: this gradient should be mode specific
                grad_vjk[i] += lib.einsum("Xpq, X, X->pq", gtmp, scaled_mu, dg)

            # DSE-mediated K
            # vk_dse[i] += lib.einsum("Xpr, Xqs, rs -> pq", gtmp, gtmp, dm[i])
            gdm = lib.einsum("Xqs, rs -> Xqr", gtmp, dm[i])
            vk_dse[i] += lib.einsum("Xpr, Xqr, X-> pq", gtmp, gdm, gvar2)
            if compute_grad:
                # FIXME: this gradient should be mode specific
                grad_vjk[i] -= 0.5 * lib.einsum("Xpr, Xqr, X-> pq", gtmp, gdm, dg)

        vj = vj_dse.reshape(dm_shape)
        vk = vk_dse.reshape(dm_shape)
        if compute_grad:
            grad_vjk = grad_vjk.reshape(dm_shape)
            return vj, vk, grad_vjk
        return vj, vk


    def get_jk(self, mol=None, dm=None, hermi=1, with_j=True, with_k=True, omega=None):
        if mol is None: mol = self.mol
        if dm is None: dm = self.make_rdm1()

        # Note the incore version, which initializes an _eri array in memory.
        if not omega and (
            self._eri is not None or mol.incore_anyway or self._is_mem_enough()
        ):
            if self._eri is None:
                self._eri = mol.intor("int2e", aosym="s8")
            vj, vk = hf.dot_eri_dm(self._eri, dm, hermi, with_j, with_k)
        else:
            vj, vk = RHF.get_jk(self, mol, dm, hermi, with_j, with_k, omega)

        if self.qed.add_dse:
            vj_dse, vk_dse = self.get_dse_jk(dm)
            vj += vj_dse
            vk += vk_dse

        return vj, vk


    # keep bare get_hcore, get_jk and get_veff functions
    # can be easily overwritten by custom Hamiltonian
    def get_bare_hcore(self, mol=None):
        if mol is None: mol = self.mol
        return hf.get_hcore(mol)


    def get_bare_jk(self, mol=None, dm=None, hermi=1,
                    with_j=True, with_k=True, omega=None):
        if mol is None: mol = self.mol
        if dm is None: dm = self.make_rdm1()

        # Note the incore version, which initializes an _eri array in memory.
        if (not omega and
            (self._eri is not None or mol.incore_anyway or self._is_mem_enough())):
            if self._eri is None:
                self._eri = mol.intor('int2e', aosym='s8')
            vj, vk = hf.dot_eri_dm(self._eri, dm, hermi, with_j, with_k)
        else:
            vj, vk = hf.SCF.get_jk(self, mol, dm, hermi, with_j, with_k, omega)
        return vj, vk


    def get_bare_veff(self, mol=None, dm=None, dm_last=0, vhf_last=0, hermi=1):
        if mol is None: mol = self.mol
        if dm is None: dm = self.make_rdm1()

        if self._eri is not None or not self.direct_scf:
            vj, vk = self.get_bare_jk(mol, dm, hermi)
            vhf = vj - vk * .5
        else:
            ddm = numpy.asarray(dm) - numpy.asarray(dm_last)
            vj, vk = self.get_bare_jk(mol, ddm, hermi)
            vhf = vj - vk * .5
            vhf += numpy.asarray(vhf_last)
        return vhf


    def get_veff(self, mol=None, dm=None, dm_last=0, vhf_last=0, hermi=1):
        r"""Return DSE-mediated potential matrix, :math:`V^{\text{QED}}_{\text{HF}}`.

        Overwrite :meth:`hf.RHF.get_veff <pyscf.scf.hf.RHF.get_veff>`.
        Use parent function to compute non-QED potential, :math:`V_{\text{HF}}`
        then call :meth:`~lib.boson.Boson.get_dse_jk` in :attr:`qed` object
        for the DSE-mediated Coulomb :math:`(J)` and Exchange :math:`(K)`
        matrices, added before return.

        .. math::

            V^{\text{QED}}_{\text{HF}} = V_{\text{HF}}
                                   + (J^{\text{QED}} - \frac{1}{2} K^{\text{QED}})

        Keyword Arguments
        -----------------
        mol : :class:`MoleBase <pyscf.gto.mole.MoleBase>`
            PySCF molecule object.
        dm : :class:`~numpy.ndarray`
            Density matrix.
        dm_last : :class:`~numpy.ndarray`
            Previous density matrix.
        vhf_last : :class:`~numpy.ndarray`
            Previous potential matrix.
        hermi : int
            Whether :math:`J` and :math:`K` are Hermitian.
            **Optional**, ``default = 1``.

                - 0 : not Hermitian and not symmetric
                - 1 : Hermitian or symmetric
                - 2 : anti-Hermitian

        Return
        -------
        vhf : :class:`~numpy.ndarray`
            DSE-mediated potential matrix,
            :math:`V^{\text{QED}}_{\text{HF}}`.
        """

        if mol is None: mol = self.mol
        if dm is None: dm = self.make_rdm1()

        if self.qed.use_cs: # TODO: Necessary?
            self.qed.update_cs(dm)

        if self._eri is not None or not self.direct_scf:
            vj, vk = self.get_jk(mol, dm, hermi)
            vhf = vj - vk * 0.5
        else:
            ddm = numpy.asarray(dm) - numpy.asarray(dm_last)
            vj, vk = self.get_jk(mol, ddm, hermi)
            vhf = vj - vk * 0.5
            vhf += numpy.asarray(vhf_last)

        return vhf


    get_fock = get_fock


    def energy_elec(self, dm=None, h1e=None, vhf=None):
        r"""
        Return total electronic energy and 2e- component.

        Copy of :func:`hf.energy_elec <pyscf.scf.hf.energy_elec>`
        function, modified to account for :func:`get_hcore`
        having density matrix dependence in :class:`RHF`.

        Parameters
        ----------
        dm : :class:`~numpy.ndarray`
            Density matrix. If ``None``,
            :external:func:`~pyscf.scf.hf.make_rdm1` called.

        h1e : :class:`~numpy.ndarray`
            Core QED-HF Hamiltonian. If ``None``,
            :meth:`~RHF.get_hcore` called.

        vhf : :class:`~numpy.ndarray`
            QED-HF potential matrix.
            **Optional**, (computed by function if not provided).

        Returns
        -------
        float, float
            Sum of 1e- and 2e- energy components, 2e- energy component
        """

        if dm is None: dm = self.make_rdm1()
        if h1e is None: h1e = self.get_hcore(self.mol, dm)
        if vhf is None: vhf = self.get_veff(self.mol, dm)

        e1 = lib.einsum('ij,ji->', h1e, dm).real
        self.scf_summary['e1'] = e1

        e_coul = lib.einsum('ij,ji->', vhf, dm).real * .5
        self.scf_summary['e2'] = e_coul

        logger.debug(self, 'E1 = %s  E_coul = %s', e1, e_coul)
        return e1+e_coul, e_coul


    def scf(self, dm0=None, **kwargs):
        r"""
        Return total energy of :class:`RHF`.

        Copy of :meth:`hf.SCF.scf <pyscf.scf.hf.SCF.scf>`
        function, overwritten in :class:`RHF` for proper call
        of :func:`kernel` function in :mod:`~openms.mqed.qedhf`
        module. Initial density matrix guess moved here from
        kernel function, to allow for computing initial QED
        quantities that require electronic density matrix, such
        as the :math:`\boldsymbol{z}_{\alpha}` values for calculations
        being performed with the photonic wavefunction in the
        coherent-state (CS) represenation.

        Keyword Arguments
        -----------------
        dm0 : :class:`~numpy.ndarray`
            Initial guess density matrix. If not given (the default),
            the kernel takes the density matrix generated by
            :external:meth:`~pyscf.scf.hf.SCF.get_init_guess`.

        Returns
        -------
        float
            Electronic energy of last SCF iteration.
        """

        cput0 = (logger.process_clock(), logger.perf_counter())

        self.dump_flags()
        self.build(self.mol)

        if self.max_cycle > 0 or self.mo_coeff is None:
            self.converged, self.e_tot, \
                    self.mo_energy, self.mo_coeff, self.mo_occ = \
                    kernel(self, self.conv_tol, self.conv_tol_grad,
                           dm0=dm0, callback=self.callback,
                           conv_check=self.conv_check, **kwargs)
        else:
            self.e_tot = kernel(self, self.conv_tol, self.conv_tol_grad,
                                dm0=dm0, callback=self.callback,
                                conv_check=self.conv_check, **kwargs)[1]

        logger.timer(self, 'SCF', *cput0)
        self._finalize()
        return self.e_tot
    kernel = lib.alias(scf, alias_name='kernel')


    def _finalize(self):
        r"""Hook for dumping results and clearing up the object."""
        if self.converged:
            logger.note(self, 'converged SCF energy = %.15g', self.e_tot)
            logger.note(self, 'converged z = [%s]', ', '.join(f'{z:.15g}' for z in self.qed.z_alpha))
            logger.note(self, 'converged f = [%s]', ', '.join(f'{f:.15g}' for f in self.qed.couplings_var))
            logger.note(self, 'converged F = [%s]', ', '.join(f'{f:.15g}' for f in self.qed.squeezed_var))
        else:
            logger.note(self, 'SCF not converged.')
            logger.note(self, 'SCF energy = %.15g', self.e_tot)
        return self


    def post_kernel(self, envs):
        r"""Prints relevant citation information for calculation."""
        breakline = '='*80
        logger.note(self, f"\n{breakline}")
        logger.note(self, f"*  Hooray, the job is done!\n")

        logger.note(self, f"Citations:\n")
        for i, key in enumerate(openms.runtime_refs):
            logger.note(self, f"[{i+1}]. {openms._citations[key]}")
        logger.note(self, f"{breakline}\n")

        return self

    def make_boson_nocc_org(self, nfock=10):
        r"""boson occ in original fock representation"""
        import math

        _, _, rho_b = self.make_rdm1_org(self.mo_coeff, self.mo_occ, nfock=nfock)
        nocc = numpy.dot(numpy.diagonal(rho_b), numpy.array(range(nfock)))
        print("nocc =", nocc)
        return nocc

    def make_rdm1_org(self, mo_coeff, mo_occ, nfock=2, **kwargs):

        from math import factorial

        mocc = mo_coeff[:,mo_occ>0]
        rho = (mocc*mo_occ[mo_occ>0]).dot(mocc.conj().T)

        nao = rho.shape[0]
        imode = 0

        rho_tot = numpy.zeros((nfock, nao, nfock, nao))
        for m in range(nfock):
            for n in range(nfock):
                # <m | D(z_alpha) |0>
                zalpha = self.qed.z_alpha[imode]

                z0 = numpy.exp(-0.5 * zalpha ** 2)
                zm = z0 * zalpha ** m * numpy.sqrt(factorial(m))
                zn = z0 * zalpha ** n * numpy.sqrt(factorial(n))
                rho_tmp = rho * zm * zn
                # back to AO
                rho_tot[m, :, n, :] = rho_tmp

        rho_e = numpy.einsum("mpmq->pq", rho_tot)
        rho_b = numpy.einsum("mpnp->mn", rho_tot) / numpy.trace(rho_e)

        return rho_tot, rho_e, rho_b


    def dump_flags(self, verbose=None):
        r"""Parent method overwritten to include :class:`~lib.boson.Boson` flags."""
        self.qed.dump_flags()
        super().dump_flags(verbose)

    # --------------------------------
    # SC/VT-QED-RHF method definitions
    # --------------------------------

    def set_params(self, params, fock_shape=None):
        r"""Reshape Fock after DIIS."""
        if fock_shape is not None:
            fsize = numpy.prod(fock_shape)
            f = params[:fsize].reshape(fock_shape)
            return f

    def get_h1e_DO(self, mol=None, dm=None):
        r"""Template method to get one-body terms in dipole operator basis."""
        pass

    def init_var_params(self, dm=None):
        r"""Template method to initialize SC/VT-QED-HF variational parameters."""
        pass

    def grad_var_params(self, dm=None):
        r"""Template method to compute SC/VT-QED-HF energy gradients w.r.t. variational parameters."""
        pass

    def norm_var_params(self):
        r"""Template method to return the norm of SC/VT-QED-HF variational parameters."""
        return 0.0

    def pre_update_var_params(self):
        r"""Template method to prepare SC/VT-QED-HF variational parameters for DIIS update."""
        return None, None

    def update_var_params(self):
        r"""Template method to update SC/VT-QED-HF variational parameters."""
        pass


class RKS(rks.KohnShamDFT, RHF):
    r"""Template class for QED-RKS. WIP."""
    def __init__(self, mol, xc="LDA,VWN", **kwargs):
        RHF.__init__(self, mol, **kwargs)
        rks.KohnShamDFT.__init__(self, xc)

    def dump_flags(self, verbose=None):
        r"""Parent method overwritten to include :class:`~lib.boson.Boson` flags."""
        RHF.dump_flags(self, verbose)
        return rks.KohnShamDFT.dump_flags(self, verbose)

    get_veff = rks.get_veff
    get_vsap = rks.get_vsap
    energy_elec = rks.energy_elec


if __name__ == "__main__":
    import numpy
    from pyscf import gto

    atom = """
           C    0.00000000    0.00000000    0.00000000
           O    0.00000000    1.23456800    0.00000000
           H    0.97075033   -0.54577032    0.00000000
           C   -1.21509881   -0.80991169    0.00000000
           H   -1.15288176   -1.89931439    0.00000000
           C   -2.43440063   -0.19144555    0.00000000
           H   -3.37262777   -0.75937214    0.00000000
           O   -2.62194056    1.12501165    0.00000000
           H   -1.71446384    1.51627790    0.00000000
           """

    mol = gto.M(atom = atom,
                basis="sto3g",
                unit="Angstrom",
                symmetry=True,
                verbose=3,
    )

    nmode = 2
    cavity_freq = numpy.zeros(nmode)
    cavity_freq[0] = 0.5
    cavity_mode = numpy.zeros((nmode, 3))
    cavity_mode[0, :] = 0.1 * numpy.asarray([0, 0, 1])

    qedmf = RHF(mol, cavity_mode=cavity_mode, cavity_freq=cavity_freq)
    qedmf.max_cycle = 500
    qedmf.kernel()
    print(f"Total energy:     {qedmf.e_tot:.10f}")

    qed = qedmf.qed

    # get I
    qed.kernel()
    I = qed.get_I()
    F = qed.g_fock()
