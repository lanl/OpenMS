#
# @ 2023. Triad National Security, LLC. All rights reserved.
#
# This program was produced under U.S. Government contract 89233218CNA000001
# for Los Alamos National Laboratory (LANL), which is operated by Triad
# National Security, LLC for the U.S. Department of Energy/National Nuclear
# Security Administration. All rights in the program are reserved by Triad
# National Security, LLC, and the U.S. Department of Energy/National Nuclear
# Security Administration. The Government is granted for itself and others acting
# on its behalf a nonexclusive, paid-up, irrevocable worldwide license in this
# material to reproduce, prepare derivative works, distribute copies to the
# public, perform publicly and display publicly, and to permit others to do so.
#
# Authors:   Yu Zhang    <zhy@lanl.gov>
#          Ilia Mazin <imazin@lanl.gov>
#

import numpy
from scipy import linalg

from pyscf import dft
from pyscf import lib
from pyscf import scf
from pyscf.lib import logger

import openms
from openms.lib import boson
from openms import __config__

TIGHT_GRAD_CONV_TOL = getattr(__config__, "TIGHT_GRAD_CONV_TOL", True)

r"""
Theoretical background of QEDHF
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Within the Coherent State (CS) representation (for photonic DOF), the
QEDHF wavefunction ansatz is

.. math::

   \ket{\Psi} = &\sum_n c_n \prod_\alpha e^{z_\alpha b^\dagger_\alpha - z^*_\alpha b_\alpha } \ket{HF}\otimes{n_\alpha} \\
              = &\sum_n c_n U(\mathbf{z}) \ket{HF}\otimes{n_\alhpa}.

where :math:`z_\alpha=-\frac{\lambda_\alpha\cdot\langle\boldsymbol{D}\rangle}{\sqrt{2\omega_\alpha}}` denotes
the photon displacement due to the coupling with electrons.

Consequently, we can use :math:`U(\mathbf{z})` to transform the original PF Hamiltonian
into CS representation

.. math::

    H_{CS} = & U^\dagger(\mathbf{z}) H U(\mathbf{z}) \\
           = & H_e+\sum_\alpha\Big\{\omega_\alpha b^\dagger_\alpha b_\alpha
               +\frac{1}{2}[\lambda_\alpha\cdot(\boldsymbol{D}-\langle\boldsymbol{D}\rangle)]^2  \\
             & -\sqrt{\frac{\omega_\alpha}{2}}[\lambda_\alpha\cdot(\boldsymbol{D} -
             \langle\boldsymbol{D}\rangle)](b^\dagger_\alpha+ b_\alpha)\Big\}.


With the ansatz, the QEDHF energy is

.. math::

  E_{QEDHF}= E_{HF} + \frac{1}{2}\langle \boldsymbol{lambda}\cdot [\boldsymbol{D}-\langle \boldsymbol{D}\rangle)]^2\rangle,

"""

def kernel(
    mf, conv_tol=1e-10, conv_tol_grad=None,
    dump_chk=True, dm0=None, callback=None, conv_check=True, **kwargs):
    r"""
    SCF kernel: the main QED-HF driver.

    Modified version of :external:func:`hf.kernel <pyscf.scf.hf.kernel>`
    from PySCF. The main difference is:

    - updating one-electron integrals with :meth:`~RHF.get_hcore` within
      the SCF cycle, due to new DSE-mediated terms in the OEI which depend
      on the electronic density matrix, ``dm``.

    Parameters
    ----------
    mf : :class:`RHF <mqed.qedhf.RHF>`
        Instance of OpenMS mean-field class.

    Keyword Arguments
    -----------------
    conv_tol : float
        Energy convergence threshold.
        **Optional**, ``default = 1e-10``.
    conv_tol_grad : float
        Energy gradients convergence threshold.
        **Optional**, ``default = sqrt(conv_tol)``.
    dump_chk : bool
        Whether to save SCF intermediate results
        in the checkpoint file.
        **Optional**, ``default = True``.
    dm0 : :class:`~numpy.ndarray`
        Initial guess density matrix. If not given (the default),
        the kernel takes the density matrix generated by
        :external:meth:`~pyscf.scf.hf.SCF.get_init_guess`.
    callback : function(envs_dict) => None
        callback function takes one ``dict`` as the argument which
        is generated by built-in function :func:`locals`, so that
        the callback function can access all local variables in the
        current environment.
    conv_check : bool
        Whether to perform an additional SCF cycle after convergence
        criteria are met. **Optional**, ``default = True``.

    Return
    ------
    scf_conv : bool
        Whether SCF has converged.
    e_tot : float
        QED Hartree-Fock energy of last iteration.
    mo_energy : :class:`~numpy.ndarray`
        Orbital energies. Depending on the ``eig`` function provided by
        ``mf`` object, the orbital energies may **NOT** be sorted.
    mo_coeff : :class:`~numpy.ndarray`
        Orbital coefficients.
    mo_occ : :class:`~numpy.ndarray`
        Orbital occupancies. The occupancies may **NOT** be sorted from
        large to small.
    """

    if 'init_dm' in kwargs:
        err_msg = "You see this error message because of the API " + \
                  "updates in pyscf v0.11. Keyword argument 'init_dm' " + \
                  "is replaced by 'dm0'"
        raise RuntimeError(err_msg)

    cput0 = (logger.process_clock(), logger.perf_counter())

    if conv_tol_grad is None:
        conv_tol_grad = numpy.sqrt(conv_tol)
        log_msg = f"Set gradient convergence threshold to {conv_tol_grad}"
        logger.info(mf, log_msg)

    mol = mf.mol
    s1e = mf.get_ovlp(mol)

    if dm0 is None:
        dm = mf.get_init_guess(mol, mf.init_guess)
    else:
        dm = dm0

    # Initial (bare) electronic energy
    h1e = mf.bare_h1e = mf.get_bare_hcore(mol)
    vhf = scf.hf.get_veff(mol, dm)
    e_tot = mf.energy_tot(dm, h1e, vhf)
    logger.info(mf, 'init E (non-QED)= %.15g', e_tot)

    # Create initial photonic eigenvector guess(es)
    mf.qed.update_boson_coeff(e_tot, dm)

    # Initialize additional variational parameters,
    # construct 'h1e' 'gmat' in dipole (DO) basis
    # (used by SC-QED-HF/VT-QED-HF subclasses)
    mf.init_var_params(dm)
    mf.get_h1e_DO(mol, dm)

    scf_conv = False
    mo_energy = mo_coeff = mo_occ = None

    # Skip SCF iterations. Compute only the total energy of the initial density
    if mf.max_cycle <= 0:
        fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf, no DIIS
        mo_energy, mo_coeff = mf.eig(fock, s1e)
        mo_occ = mf.get_occ(mo_energy, mo_coeff)
        return scf_conv, e_tot, mo_energy, mo_coeff, mo_occ

    # Setup DIIS parameters
    if isinstance(mf.diis, lib.diis.DIIS):
        mf_diis = mf.diis
    elif mf.diis:
        assert issubclass(mf.DIIS, lib.diis.DIIS)
        mf_diis = mf.DIIS(mf, mf.diis_file)
        mf_diis.space = mf.diis_space
        mf_diis.rollback = mf.diis_space_rollback

        # We get the used orthonormalized AO basis from any old eigendecomposition.
        # Since the ingredients for the Fock matrix have already been built, we can
        # just go ahead and use it to determine the orthonormal basis vectors.
        fock = mf.get_fock(h1e, s1e, vhf, dm)
        _, mf_diis.Corth = mf.eig(fock, s1e)
    else:
        mf_diis = None

    if dump_chk and mf.chkfile:
        # Explicitly overwrite the mol object in chkfile
        # Note in pbc.scf, mf.mol == mf.cell, cell is saved under key "mol"
        scf.chkfile.save_mol(mol, mf.chkfile)

    # A preprocessing hook before the SCF iteration(s)
    mf.pre_kernel(locals())
    mf.check_sanity()

    cput1 = logger.timer(mf, 'initialize scf', *cput0)
    for cycle in range(mf.max_cycle):
        dm_last = dm
        last_hf_e = e_tot

        # Update gradients of additional variational parameters
        # and 'h1e' in DO basis (used by SC-QED-HF/VT-QED-HF subclasses)
        mf.get_h1e_DO(mol, dm)
        mf.grad_var_params(dm)

        h1e = mf.get_hcore(mol, dm)
        fock = mf.get_fock(h1e, s1e, vhf, dm, cycle, mf_diis)

        # Diagonalize Fock matrix and update density matrix
        mo_energy, mo_coeff = mf.eig(fock, s1e)
        mo_occ = mf.get_occ(mo_energy, mo_coeff)
        dm = mf.make_rdm1(mo_coeff, mo_occ)

        # Update photonic coefficients and compute photonic energy
        mf.qed.update_cs(dm) # Update coherent state values

        # Update h1e, vhf, and e_tot
        h1e = mf.get_hcore(mol, dm)
        vhf = mf.get_veff(mol, dm, dm_last, vhf)
        e_tot = mf.energy_tot(dm, h1e, vhf)

        # construct Hp matrix and diagonalize
        mf.qed.update_boson_coeff(e_tot, dm)

        # Check SCF convergence
        fock = mf.get_fock(h1e, s1e, vhf, dm)  # = h1e + vhf, no DIIS
        norm_eta = mf.norm_var_params()
        norm_gorb = numpy.linalg.norm(mf.get_grad(mo_coeff, mo_occ, fock))
        norm_gorb += norm_eta
        if not TIGHT_GRAD_CONV_TOL:
            norm_gorb = norm_gorb / numpy.sqrt(norm_gorb.size)
        norm_ddm = numpy.linalg.norm(dm-dm_last)
        logger.info(mf, 'cycle= %d E= %.15g  delta_E= %4.3g  |g|= %4.3g  |ddm|= %4.3g',
                    cycle+1, e_tot, e_tot-last_hf_e, norm_gorb, norm_ddm)

        if callable(mf.check_convergence):
            scf_conv = mf.check_convergence(locals())
        elif abs(e_tot-last_hf_e) < conv_tol and norm_gorb < conv_tol_grad:
            scf_conv = True

        if dump_chk:
            mf.dump_chk(locals())

        if callable(callback):
            callback(locals())

        cput1 = logger.timer(mf, 'cycle= %d'%(cycle+1), *cput1)

        if scf_conv:
            break

    if scf_conv and conv_check:

        # An extra diagonalization, to remove level shift
        mo_energy, mo_coeff = mf.eig(fock, s1e)
        mo_occ = mf.get_occ(mo_energy, mo_coeff)
        dm, dm_last = mf.make_rdm1(mo_coeff, mo_occ), dm

        # Final update of photonic coefficients and energy
        mf.qed.update_cs(dm) # Update coherent state values

        mf.qed.update_boson_coeff(e_tot, dm)

        # Final update of h1e, vhf, e_tot, fock
        h1e = mf.get_hcore(mol, dm)
        vhf = mf.get_veff(mol, dm)
        e_tot, last_hf_e = mf.energy_tot(dm, h1e, vhf), e_tot
        fock = mf.get_fock(h1e, s1e, vhf, dm)

        # Verify SCF convergence
        norm_eta = mf.norm_var_params()
        norm_gorb = numpy.linalg.norm(mf.get_grad(mo_coeff, mo_occ, fock))
        norm_gorb = norm_gorb + norm_eta
        if not TIGHT_GRAD_CONV_TOL:
            norm_gorb = norm_gorb / numpy.sqrt(norm_gorb.size)
        norm_ddm = numpy.linalg.norm(dm-dm_last)

        conv_tol = conv_tol * 10
        conv_tol_grad = conv_tol_grad * 3
        if callable(mf.check_convergence):
            scf_conv = mf.check_convergence(locals())
        elif abs(e_tot-last_hf_e) < conv_tol or norm_gorb < conv_tol_grad:
            scf_conv = True
        logger.info(mf, 'Extra cycle  E= %.15g  delta_E= %4.3g  |g|= %4.3g  |ddm|= %4.3g',
                    e_tot, e_tot-last_hf_e, norm_gorb, norm_ddm)
        if dump_chk:
            mf.dump_chk(locals())

    logger.timer(mf, 'scf_cycle', *cput0)
    # A post-processing hook before return
    mf.post_kernel()
    return scf_conv, e_tot, mo_energy, mo_coeff, mo_occ


def get_fock(
    mf,
    h1e=None,
    s1e=None,
    vhf=None,
    dm=None,
    cycle=-1,
    diis=None,
    diis_start_cycle=None,
    level_shift_factor=None,
    damp_factor=None,
):
    r"""
    Return Fock matrix in AO basis, :math:`F = h_{core} + V_{HF}`.

    Copy of :func:`hf.get_fock <pyscf.scf.hf.get_fock>`
    from PySCF with some differences:

        1. Generalize DIIS to include other variational parameters,
        2. Pre- and post-processing of variational parameters with
           :meth:`update_var_params` & :meth:`pre_update_var_params`,
        3. ``h1e`` depends on the density matrix.

    Parameters
    ----------
    mf : :class:`RHF <mqed.qedhf.RHF>`
        Instance of OpenMS mean-field class.

    Keyword Arguments
    -----------------
    h1e : :class:`~numpy.ndarray`
        Core QED-HF Hamiltonian. If ``None``,
        :meth:`~RHF.get_hcore` called.
    s1e : :class:`~numpy.ndarray`
        Overlap matrix, for DIIS. If ``None``,
        :external:func:`~pyscf.scf.hf.get_ovlp` called.
    vhf : :class:`~numpy.ndarray`
        QED-HF potential matrix. If ``None``,
        :meth:`~RHF.get_veff` called.
    dm : :class:`~numpy.ndarray`
        Density matrix. If ``None``,
        :external:func:`~pyscf.scf.hf.make_rdm1` called.
    cycle : int
        Present SCF iteration step, for DIIS,
        ``default = -1``.
    diis : :external:class:`~pyscf.lib.diis.DIIS`
        DIIS object to hold intermediate Fock and error
        vectors.
    diis_start_cycle : int
        The step to start DIIS, **optional**
        ``default = 0``.
    level_shift_factor : float
        Level shift (in AU) for virtual space, **optional**
        ``default = 0``.
    damp_factor : float
        Damping factor for Fock matrix, **optional**
        ``default = 0``.

    Return
    ------
    f : :class:`~numpy.ndarray`
        Fock matrix.
    """

    if cycle > -1:
        mf.update_var_params()

    if h1e is None:
        h1e = mf.get_hcore(mf.mol, dm)
    if vhf is None:
        vhf = mf.get_veff(mf.mol, dm)

    f = h1e + vhf

    if cycle < 0 and diis is None:  # Not inside the SCF iteration
        return f

    if diis_start_cycle is None:
        diis_start_cycle = mf.diis_start_cycle
    if level_shift_factor is None:
        level_shift_factor = mf.level_shift
    if damp_factor is None:
        damp_factor = mf.damp

    if dm is None: dm = mf.make_rdm1()
    if s1e is None: s1e = mf.get_ovlp()

    if 0 <= cycle < diis_start_cycle - 1 and abs(damp_factor) > 1e-4:
        f = damping(s1e, dm * 0.5, f, damp_factor)
    if diis is not None and cycle >= diis_start_cycle:
        variables, gradients = mf.pre_update_var_params()
        params = diis.update(s1e, dm, f, mf, h1e, vhf,
                             var=variables, var_grad=gradients)
        f = mf.set_params(params, fock_shape=f.shape)
    if abs(level_shift_factor) > 1e-4:
        f = level_shift(s1e, dm * 0.5, f, level_shift_factor)
    return f


class RHF(scf.hf.RHF):
    r"""Non-relativistic QED-RHF class."""
    def __init__(
        self, mol, qed=None, xc=None, **kwargs):

        logger.info(self, openms.__logo__)

        if xc is not None:
            raise NotImplementedError("RKS object currently not supported.")
        else:
            super().__init__(mol)

        self.nao = mol.nao_nr()
        self.bare_h1e = None
        self.qed = None

        cavity_options = kwargs
        if qed is None:

            qed_req_args = ["omega", "vec"]
            if not all(i in kwargs for i in qed_req_args):
                err_msg = f"Must provide either Boson object in 'qed' " + \
                          f"parameter, OR 'omega', 'vec', parameters."
                logger.error(self, err_msg)
                raise ValueError(err_msg)

            else:
                self.qed = boson.Photon(mol, mf=self, **kwargs)

        elif qed is not None and (not isinstance(qed, boson.Boson)):
            err_msg = f"The 'qed' parameter is not an " + \
                      f"instance of OpenMS Boson class."
            logger.error(self, err_msg)
            raise ValueError(err_msg)

        else:
            self.qed = qed

        # Update QED object
        # self.qed.update_mean_field(self, **kwargs)

        # update the setting according to each specific MF
        # couplings_var should be zero in QEDHF
        qed.couplings_var = numpy.zeros(qed.nmodes)
        qed.update_couplings()

        self.qed = qed

        # make dipole matrix in AO
        #self.make_dipolematrix() # replaced by qed functions

        self.qed.get_gmatao()
        self.qed.get_q_dot_lambda()
        self.gmat = self.qed.gmat


    def get_oei_AO(self):
        r"""return the effective oei in AO for usage in QMC
        """
        pass

    def get_eri_AO(sefl, Ltensor=True):
        r"""return the effective eri (or chols) in AO for usage in QMC
        """
        pass

    def get_bare_hcore(self, mol=None):
        r"""return the bare hcore"""
        if mol is None: mol = self.mol
        return scf.hf.get_hcore(mol)

    def get_hcore(self, mol=None, dm=None):
        r"""
        Return non-QED or DSE-mediated OEI in AO basis.

        If ``dm=None``, return non-QED OEI, stored in
        :attr:`bare_h1e`.

        Else, call :meth:`~lib.boson.Photon.get_dse_hcore`
        from :attr:`qed` object to return the DSE-mediated
        OEI contribution.

        Keyword Arguments
        -----------------
        mol : :class:`MoleBase <pyscf.gto.mole.MoleBase>`
            PySCF molecule object. If ``None``, copied from
            :attr:`mol` attribute.
        dm : :class:`~numpy.ndarray`
            Density matrix, **optional**.

        Returns
        -------
        :class:`~numpy.ndarray`
            non-QED OEI or DSE-mediated OEI.
        """

        if mol is None: mol = self.mol

        if dm is None:
            return self.bare_h1e
        else:
            dse_h1e = self.qed.get_dse_hcore(dm)
            return (self.bare_h1e + dse_h1e)


    def get_veff(
        self, mol=None, dm=None, dm_last=0, vhf_last=0, hermi=1):
        r"""
        Return DSE-mediated potential matrix, :math:`V^{\tt{QED}}_{\tt{HF}}`.

        Overwrite :meth:`hf.RHF.get_veff <pyscf.scf.hf.RHF.get_veff>`.
        Use parent function to compute non-QED potential, :math:`V_{\tt{HF}}`
        then call :meth:`~lib.boson.Boson.get_dse_jk` in :attr:`qed` object
        for the DSE-mediated Coulomb :math:`(J)` and Exchange :math:`(K)`
        matrices, added before return.

        .. math::
            V^{\tt{QED}}_{\tt{HF}} = V_{\tt{HF}}
                                   + (J^{\tt{QED}} - \frac{1}{2} K^{\tt{QED}})

        Keyword Arguments
        -----------------
        mol : :class:`MoleBase <pyscf.gto.mole.MoleBase>`
            PySCF molecule object.
        dm : :class:`~numpy.ndarray`
            Density matrix.
        dm_last : :class:`~numpy.ndarray`
            Previous density matrix.
        vhf_last : :class:`~numpy.ndarray`
            Previous potential matrix.
        hermi : int
            Whether :math:`J` and :math:`K` are Hermitian.
            **Optional**, ``default = 1``.

                - 0 : not Hermitian and not symmetric
                - 1 : Hermitian or symmetric
                - 2 : anti-Hermitian

        Return
        -------
        vhf : :class:`~numpy.ndarray`
            DSE-mediated potential matrix,
            :math:`V^{\tt{QED}}_{\tt{HF}}`.
        """

        bare_vhf = super().get_veff(mol, dm, dm_last, vhf_last, hermi)

        vj_dse, vk_dse = self.qed.get_dse_jk(dm)
        vhf = bare_vhf + (vj_dse - vk_dse * .5)
        return vhf


    get_fock = get_fock


    def get_init_guess(self, mol=None, key='minao', **kwargs):
        r"""Return density matrix for specified-type of initial guess.

        Overwrites parent method to update QED-specific values with
        electronic density matrix dependence.
        """

        dm = super().get_init_guess(mol, key, **kwargs)
        if self.qed is not None:
            self.qed.update_cs(dm)
        return dm


    def energy_elec(self, dm=None, h1e=None, vhf=None):
        r"""
        Return total electronic energy and 2e- component.

        Copy of :func:`hf.energy_elec <pyscf.scf.hf.energy_elec>`
        function, modified to account for :func:`get_hcore`
        having density matrix dependence in :class:`RHF`.

        Parameters
        ----------
        dm : :class:`~numpy.ndarray`
            Density matrix. If ``None``,
            :external:func:`~pyscf.scf.hf.make_rdm1` called.

        h1e : :class:`~numpy.ndarray`
            Core QED-HF Hamiltonian. If ``None``,
            :meth:`~RHF.get_hcore` called.

        vhf : :class:`~numpy.ndarray`
            QED-HF potential matrix.
            **Optional**, (computed by function if not provided).

        Returns
        -------
        float, float
            Sum of 1e- and 2e- energy components, 2e- energy component
        """

        if dm is None: dm = self.make_rdm1()
        if h1e is None: h1e = self.get_hcore(self.mol, dm)
        if vhf is None: vhf = self.get_veff(self.mol, dm)

        e1 = lib.einsum('ij,ji->', h1e, dm).real
        self.scf_summary['e1'] = e1

        e_coul = lib.einsum('ij,ji->', vhf, dm).real * .5
        self.scf_summary['e2'] = e_coul

        logger.debug(self, 'E1 = %s  E_coul = %s', e1, e_coul)
        return e1+e_coul, e_coul


    def scf(self, dm0=None, **kwargs):
        r"""
        Return total energy of :class:`RHF`.

        Copy of :meth:`hf.SCF.scf <pyscf.scf.hf.SCF.scf>`
        function, overwritten in :class:`RHF` for proper call
        of :func:`kernel` function in :mod:`~openms.mqed.qedhf`
        module. Initial density matrix guess moved here from
        kernel function, to allow for computing initial QED
        quantities that require electronic density matrix, such
        as the :math:`\bm{z}_{\al}` values for calculations
        being performed with the photonic wavefunction in the
        coherent-state (CS) represenation.

        Keyword Arguments
        -----------------
        dm0 : :class:`~numpy.ndarray`
            Initial guess density matrix. If not given (the default),
            the kernel takes the density matrix generated by
            :external:meth:`~pyscf.scf.hf.SCF.get_init_guess`.

        Returns
        -------
        float
            Electronic energy of last SCF iteration.
        """

        cput0 = (logger.process_clock(), logger.perf_counter())

        if dm0 is None:
            init_dm = self.get_init_guess(self.mol, self.init_guess)
        else:
            init_dm = dm0

        self.dump_flags()
        self.build(self.mol)

        if self.max_cycle > 0 or self.mo_coeff is None:
            self.converged, self.e_tot, \
                    self.mo_energy, self.mo_coeff, self.mo_occ = \
                    kernel(self, self.conv_tol, self.conv_tol_grad,
                           dm0=init_dm, callback=self.callback,
                           conv_check=self.conv_check, **kwargs)
        else:
            self.e_tot = kernel(self, self.conv_tol, self.conv_tol_grad,
                                dm0=init_dm, callback=self.callback,
                                conv_check=self.conv_check, **kwargs)[1]

        logger.timer(self, 'SCF', *cput0)
        self._finalize()
        return self.e_tot
    kernel = lib.alias(scf, alias_name='kernel')

    def _finalize(self):
        '''Hook for dumping results and clearing up the object.'''
        if self.converged:
            logger.note(self, 'converged SCF energy = %.15g', self.e_tot)
            logger.note(self, 'converged z = [%s]', ', '.join(f'{z:.15g}' for z in self.qed.z_alpha))
            logger.note(self, 'converged f = [%s]', ', '.join(f'{f:.15g}' for f in self.qed.couplings_var))
            logger.note(self, 'converged F = [%s]', ', '.join(f'{f:.15g}' for f in self.qed.squeezed_var))
        else:
            logger.note(self, 'SCF not converged.')
            logger.note(self, 'SCF energy = %.15g', self.e_tot)
        return self

    def post_kernel(self, breakline=('='*80)):
        r"""Prints relevant citation information for calculation."""
        logger.note(self, f"\n{breakline}")
        logger.note(self, f"*  Hooray, the job is done!\n")
        logger.note(self, f"Citations:\n")
        for i, key in enumerate(openms.runtime_refs):
            logger.note(self, f"[{i+1}]. {openms._citations[key]}")
        logger.note(self, f"{breakline}\n")
        return self

    def make_rdm1_org(self, mo_coeff, mo_occ, nfock=2, **kwargs):
        r"""
        """
        import math

        mocc = mo_coeff[:,mo_occ>0]
        rho = (mocc*mo_occ[mo_occ>0]).dot(mocc.conj().T)

        nao = rho.shape[0]
        imode = 0

        rho_tot = numpy.zeros((nfock, nao, nfock, nao))
        for m in range(nfock):
            for n in range(nfock):
                # <m | D(z_alpha) |0>
                zalpha = self.qed.z_alpha[imode]

                z0 = numpy.exp(-0.5 * zalpha ** 2)
                zm = z0 * zalpha ** m * numpy.sqrt(math.factorial(m))
                zn = z0 * zalpha ** n * numpy.sqrt(math.factorial(n))
                rho_tmp = rho * zm * zn
                # back to AO
                rho_tot[m, :, n, :] = rho_tmp

        rho_e = numpy.einsum("mpmq->pq", rho_tot)
        rho_b = numpy.einsum("mpnp->mn", rho_tot) / numpy.trace(rho)

        return rho_tot, rho_e, rho_b

    def dump_flags(self, verbose=None):
        r"""Parent method overwritten to include :class:`~lib.boson.Boson` flags."""
        self.qed.dump_flags()
        super().dump_flags(verbose)

    # --------------------------------
    # SC/VT-QED-RHF method definitions
    # --------------------------------

    def set_params(self, params, fock_shape=None):
        r"""Reshape Fock after DIIS."""
        fsize = numpy.prod(fock_shape)
        f = params[:fsize].reshape(fock_shape)
        return f

    def get_h1e_DO(self, mol=None, dm=None):
        r"""Template method to get one-body terms in dipole operator basis."""
        pass

    def init_var_params(self, dm=None):
        r"""Template method to initialize SC/VT-QED-HF variational parameters."""
        pass

    def grad_var_params(self, dm=None):
        r"""Template method to compute SC/VT-QED-HF energy gradients w.r.t. variational parameters."""
        pass

    def norm_var_params(self):
        r"""Template method to return the norm of SC/VT-QED-HF variational parameters."""
        return 0.0

    def pre_update_var_params(self):
        r"""Template method to prepare SC/VT-QED-HF variational parameters for DIIS update."""
        return None, None

    def update_var_params(self):
        r"""Template method to update SC/VT-QED-HF variational parameters."""
        pass


class RKS(dft.rks.KohnShamDFT, RHF):
    r"""Template class for QED-RKS. WIP."""
    def __init__(
        self, mol, xc="LDA,VWN", **kwargs):
        raise NotImplementedError("""RKS object is currently unsupported. WIP.""")
        #RHF.__init__(self, mol, **kwargs)
        #dft.rks.KohnShamDFT.__init__(self, xc)

    #get_veff = dft.rks.get_veff
    #get_vsap = dft.rks.get_vsap
    #energy_elec = dft.rks.energy_elec


if __name__ == "__main__":
    import numpy
    from pyscf import gto

    atom = """
           C    0.00000000    0.00000000    0.00000000
           O    0.00000000    1.23456800    0.00000000
           H    0.97075033   -0.54577032    0.00000000
           C   -1.21509881   -0.80991169    0.00000000
           H   -1.15288176   -1.89931439    0.00000000
           C   -2.43440063   -0.19144555    0.00000000
           H   -3.37262777   -0.75937214    0.00000000
           O   -2.62194056    1.12501165    0.00000000
           H   -1.71446384    1.51627790    0.00000000
           """

    mol = gto.M(atom = atom,
                basis = "sto-3g",
                unit = "Angstrom",
                symmetry = True,
                verbose = 3)

    nmode = 2
    cavity_freq = numpy.zeros(nmode)
    cavity_freq[0] = 0.5
    cavity_mode = numpy.zeros((nmode, 3))
    cavity_mode[0, :] = 0.1 * numpy.asarray([0, 0, 1])

    qedmf = RHF(mol, omega = cavity_freq, vec = cavity_mode)
    qedmf.max_cycle = 500
    qedmf.kernel()
